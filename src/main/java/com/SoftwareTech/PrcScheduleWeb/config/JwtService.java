package com.SoftwareTech.PrcScheduleWeb.config;

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;

import javax.crypto.KeyGenerator;
import javax.crypto.spec.SecretKeySpec;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.RSAKeyGenParameterSpec;
import java.security.spec.RSAPublicKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service
public class JwtService {
    private static final String SECRET_KEY = "EiYz1aqHzqnw9Js7IimBKIKgggJEh0Mqj1jAU7VVxc8=";

    /**JwtServices: Generating Token Methods by Custom Claims**/
    public String generateToken(Map<String, Object> customClaims, UserDetails userDetails) {
        return Jwts.builder()
            .claims(customClaims)
            .subject(userDetails.getUsername())
            .issuedAt(new Date(System.currentTimeMillis()))
            .expiration(new Date(System.currentTimeMillis()+ 15*60*1000))
            .signWith(this.getSigningKey())
            .compact();
    }

    /**JwtServices: Generating Token Methods by Registered Claims**/
    public String generateToken(UserDetails userDetails) {
        return this.generateToken(
            new HashMap<>(),    //--Just let CustomClaims is empty.
            userDetails
        );
    }

    /**JwtServices: Verifying Token if it isn't expired**/
    public boolean isNotExpiredToken(String token) {
        Date expirationDate = extractTokenAndGetAllClaims(token).getExpiration();
        return expirationDate.after(new Date(System.currentTimeMillis()));
    }

    /**JwtServices: Verifying Token if it's a valid Token (created by Spring App)**/
    public boolean isValidToken(String token, UserDetails userDetails) {
        final String originInstituteEmail = extractTokenAndGetAllClaims(token).getSubject();
        boolean isUser = userDetails.getUsername().equals(originInstituteEmail);
        boolean isNotExpired = isNotExpiredToken(token);
        return isUser && isNotExpired;
    }

    /**JwtServices: Extract Token to get Claims**/
    public String getInstituteEmail(String token) {
        return this.parseTokenAndGetClaim(token, Claims::getSubject);
    }

    /**JwtSupportingServices: Extracting Token Methods**/
    public <T> T parseTokenAndGetClaim(String token, Function<Claims, T> claimsResolverAsCallback) {
        Claims claims = this.extractTokenAndGetAllClaims(token);
        return claimsResolverAsCallback.apply(claims);
    }

    /**JwtSupportingServices: Extracting Token Methods**/
    public Claims extractTokenAndGetAllClaims(String token) {
        return Jwts.parser()            //--Getting "JwtParserBuilder" object to configure.
            .verifyWith(getSigningKey())//--Config "JwtParserBuilder" object with SIGNING_KEY.
            .build()                    //--Build "JwtParser" from configured "JwtParserBuilder".
            .parseSignedClaims(token)   //--Verify SIGNING_KEY of input Token, and extract it.
            .getPayload();              //--Return "Claims" object, contains all Claims (Payload).
    }

    /**
     * Get SIGNING_KEY (from SECRET_KEY as JWT Technique) as PublicKey.
     * <br>This SIGNING_KEY used to Generate or Parse (Verify - Extract) Token.
     * **/
    private SecretKeySpec getSigningKey() {
        //--Decode SECRET_KEY (generated by BASE64 Algorithm) to byte[].
        byte[] keyAsBytes = Decoders.BASE64.decode(SECRET_KEY);

        //--Generate SIGNING_KEY by H-MAC Algorithm with SECRET_KEY (as byte[]).
        return new SecretKeySpec(keyAsBytes, "HmacSHA256");
    }
    /*private String getRandomSecretKey() {
        try {
            return Base64.getEncoder().encodeToString(
                    KeyGenerator.getInstance("HmacSHA256")
                        .generateKey()
                        .getEncoded()
            );
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException();
        }
    }*/
}
